{
  "name": "nextjs-dodopayments",
  "description": "DodoPayments template for NextJS",
  "framework": "nextjs",
  "files": [
    {
      "target": "lib/dodopayments.ts",
      "type": "template",
      "content": "import { DodoPayments } from 'dodopayments'\ntype Product = DodoPayments.Product\n\nexport const dodopaymentsClient = new DodoPayments({\n  bearerToken: process.env.DODO_PAYMENTS_API_KEY!,\n  environment: process.env.DODO_PAYMENTS_ENVIRONMENT as \"live_mode\" | \"test_mode\",\n})\n\nexport const getProducts = async (): Promise<Product[]> => {\n  try {\n    const response = await fetch('/api/products')\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching products:', error)\n    throw error\n  }\n}\n\nexport const getProduct = async (product_id: string): Promise<Product> => {\n  try {\n    const response = await fetch(`/api/product?product_id=${product_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch product: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching product:', error)\n    throw error\n  }\n}\n\nexport const getCustomer = async (customer_id: string): Promise<DodoPayments.Customers.Customer> => {\n  try {\n    const response = await fetch(`/api/customer?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer:', error)\n    throw error\n  }\n}\n\nexport const getCustomerSubscriptions = async (customer_id: string): Promise<DodoPayments.Subscriptions.Subscription[]> => {\n  try {\n    const response = await fetch(`/api/customer/subscriptions?customer_id=${customer_id}`)\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch customer subscriptions: ${response.status} ${response.statusText}`)\n  }\n\n  return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer subscriptions:', error)\n    throw error\n  }\n}\n\nexport const getCustomerPayments = async (customer_id: string): Promise<DodoPayments.Payments.Payment[]> => {\n  try {\n    const response = await fetch(`/api/customer/payments?customer_id=${customer_id}`)\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch customer payments: ${response.status} ${response.statusText}`)\n  }\n\n  return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer payments:', error)\n    throw error\n  }\n}\n\nexport const createCustomer = async (customer: DodoPayments.Customers.CustomerCreateParams): Promise<DodoPayments.Customers.Customer> => {\n  try {\n    const response = await fetch('/api/customer', {\n      method: 'POST',\n      body: JSON.stringify(customer),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to create customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error creating customer:', error)\n    throw error\n  }\n}\n\nexport const updateCustomer = async (customer_id: string, customer: DodoPayments.Customers.CustomerUpdateParams): Promise<DodoPayments.Customers.Customer> => {\n  try {\n    const response = await fetch(`/api/customer?customer_id=${customer_id}`, {\n      method: 'PUT',\n      body: JSON.stringify(customer),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to update customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error updating customer:', error)\n    throw error\n  }\n}\n\nexport const checkout = async (productCart: Array<{ product_id: string; quantity: number; amount?: number }>, customer: DodoPayments.Payments.CustomerRequest, billing_address: DodoPayments.Payments.BillingAddress, return_url: string, customMetadata?: Record<string, string>) => {\n  try {\n    const response = await fetch('/api/checkout', {\n      method: 'POST',\n      body: JSON.stringify({ productCart, customer, billing_address, return_url, customMetadata }),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to checkout: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error checking out:', error)\n    throw error\n  }\n}"
    },
    {
      "target": "hooks/useBilling.ts",
      "type": "template",
      "content": "'use client'\n\nimport { useState, useCallback } from 'react'\nimport { DodoPayments } from 'dodopayments'\nimport {\n  getProducts,\n  getProduct,\n  getCustomer,\n  getCustomerSubscriptions,\n  getCustomerPayments,\n  createCustomer,\n  updateCustomer,\n  checkout,\n} from '@/lib/dodopayments'\n\ninterface UseBillingState {\n  loading: boolean\n  error: string | null\n}\n\nexport const useBilling = () => {\n  const [state, setState] = useState<UseBillingState>({\n    loading: false,\n    error: null,\n  })\n\n  const setLoading = useCallback((loading: boolean) => {\n    setState(prev => ({ ...prev, loading }))\n  }, [])\n\n  const setError = useCallback((error: string | null) => {\n    setState(prev => ({ ...prev, error }))\n  }, [])\n\n  const handleAsyncOperation = useCallback(async <T>(\n    operation: () => Promise<T>,\n    operationName: string\n  ): Promise<T> => {\n    try {\n      setLoading(true)\n      setError(null)\n      const result = await operation()\n      return result\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : `Failed to ${operationName}`\n      setError(errorMessage)\n      throw error\n    } finally {\n      setLoading(false)\n    }\n  }, [])\n\n  const fetchProducts = useCallback(async () => {\n    return handleAsyncOperation(() => getProducts(), 'fetch products')\n  }, [handleAsyncOperation])\n\n  const fetchProduct = useCallback(async (product_id: string) => {\n    return handleAsyncOperation(() => getProduct(product_id), 'fetch product')\n  }, [handleAsyncOperation])\n\n  const fetchCustomer = useCallback(async (customer_id: string) => {\n    return handleAsyncOperation(() => getCustomer(customer_id), 'fetch customer')\n  }, [handleAsyncOperation])\n\n  const fetchCustomerSubscriptions = useCallback(async (customer_id: string) => {\n    return handleAsyncOperation(() => getCustomerSubscriptions(customer_id), 'fetch customer subscriptions')\n  }, [handleAsyncOperation])\n\n  const fetchCustomerPayments = useCallback(async (customer_id: string) => {\n    return handleAsyncOperation(() => getCustomerPayments(customer_id), 'fetch customer payments')\n  }, [handleAsyncOperation])\n\n  const createNewCustomer = useCallback(async (customer: DodoPayments.Customers.CustomerCreateParams) => {\n    return handleAsyncOperation(() => createCustomer(customer), 'create customer')\n  }, [handleAsyncOperation])\n\n  const updateExistingCustomer = useCallback(async (\n    customer_id: string,\n    customer: DodoPayments.Customers.CustomerUpdateParams\n  ) => {\n    return handleAsyncOperation(() => updateCustomer(customer_id, customer), 'update customer')\n  }, [handleAsyncOperation])\n\n  const createCheckout = useCallback(async (\n    productCart: Array<{ product_id: string; quantity: number; amount?: number }>,\n    customer: DodoPayments.Payments.CustomerRequest,\n    billing_address: DodoPayments.Payments.BillingAddress,\n    return_url: string,\n    customMetadata?: Record<string, string>\n  ) => {\n    return handleAsyncOperation(\n      () => checkout(productCart, customer, billing_address, return_url, customMetadata),\n      'create checkout'\n    )\n  }, [handleAsyncOperation])\n\n  const clearError = useCallback(() => {\n    setError(null)\n  }, [setError])\n\n  return {\n    // State\n    loading: state.loading,\n    error: state.error,\n\n    // Actions\n    clearError,\n\n    // Product operations\n    fetchProducts,\n    fetchProduct,\n\n    // Customer operations\n    fetchCustomer,\n    fetchCustomerSubscriptions,\n    fetchCustomerPayments,\n    createNewCustomer,\n    updateExistingCustomer,\n\n    // Checkout operations\n    createCheckout,\n  }\n}\n"
    },
    {
      "target": "app/api/(dodopayments)/checkout/route.ts",
      "type": "template",
      "content": "import { dodopaymentsClient } from \"@/lib/dodopayments\";\nimport DodoPayments from \"dodopayments\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst productCartItemSchema = z.object({\n    product_id: z.string().min(1, \"Product ID is required\"),\n    quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n    amount: z.number().int().min(0).optional(),\n});\n\nconst attachExistingCustomerSchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n    email: z.string().email(\"Invalid email format\"),\n    name: z.string().min(1, \"Name is required\"),\n    phone_number: z.string().optional().nullable(),\n    create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst billingAddressSchema = z.object({\n    city: z.string().min(1, \"City is required\"),\n    country: z.string().regex(/^[A-Z]{2}$/, \"Country must be a 2-letter uppercase ISO code\"),\n    state: z.string().min(1, \"State is required\"),\n    street: z.string().min(1, \"Street address is required\"),\n    zipcode: z.string().min(1, \"Zipcode is required\"),\n});\n\nconst checkoutSessionSchema = z.object({\n    productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n    customer: customerSchema,\n    billing_address: billingAddressSchema,\n    return_url: z.string().url(\"Return URL must be a valid URL\"),\n    customMetadata: z.record(z.string(), z.string()).optional(),\n});\n\nexport async function POST(request: Request) {\n    try {\n        const body = await request.json();\n\n        const validationResult = checkoutSessionSchema.safeParse(body);\n        if (!validationResult.success) {\n            return NextResponse.json(\n                {\n                    error: \"Validation failed\",\n                    details: validationResult.error.issues.map(issue => ({\n                        field: issue.path.join('.'),\n                        message: issue.message\n                    }))\n                },\n                { status: 400 }\n            );\n        }\n\n        const { productCart, customer, billing_address, return_url, customMetadata } = validationResult.data;\n\n        const session = await dodopaymentsClient.checkoutSessions.create({\n            product_cart: productCart,\n            customer: customer,\n            billing_address: billing_address as DodoPayments.Payments.BillingAddress,\n            return_url: return_url,\n            metadata: customMetadata,\n        });\n\n        return NextResponse.json(session);\n    } catch (error) {\n        console.error('Error in checkout POST handler:', error);\n        return NextResponse.json(\n            { error: 'Internal server error' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(dodopayments)/customer/payments/route.ts",
      "type": "template",
      "content": "import { dodopaymentsClient } from \"@/lib/dodopayments\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst paymentQuerySchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);       \n        const customer_id = url.searchParams.get('customer_id');\n\n        const validationResult = paymentQuerySchema.safeParse({ customer_id });\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const validatedParams = validationResult.data;\n\n        const payments = await dodopaymentsClient.payments.list({\n            customer_id: validatedParams.customer_id,\n        });\n\n        return NextResponse.json(payments);\n    } catch (error) {\n        console.error('Error fetching customer payments:', error);\n        return NextResponse.json({ error: 'Failed to fetch customer payments' }, { status: 500 });\n    }\n}"
    },
    {
      "target": "app/api/(dodopayments)/customer/route.ts",
      "type": "template",
      "content": "import { dodopaymentsClient } from \"@/lib/dodopayments\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst customerIdSchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst createCustomerSchema = z.object({\n    email: z.string().email(\"Invalid email format\"),\n    name: z.string().min(1, \"Name is required\"),\n    phone_number: z.string().optional().nullable(),\n});\n\nconst updateCustomerSchema = z.object({\n    name: z.string().optional().nullable(),\n    phone_number: z.string().optional().nullable(),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const queryParams = {\n            customer_id: url.searchParams.get('customer_id'),\n        };\n        const validationResult = customerIdSchema.safeParse(queryParams);\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { customer_id } = validationResult.data;\n        const customer = await dodopaymentsClient.customers.retrieve(customer_id);\n        return NextResponse.json(customer);\n    } catch (error) {\n        console.error('Error retrieving customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to retrieve customer' },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function POST(request: Request) {\n    try {\n        const body = await request.json();\n\n        const validationResult = createCustomerSchema.safeParse(body);\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const customer = await dodopaymentsClient.customers.create(validationResult.data);\n        return NextResponse.json(customer);\n    } catch (error) {\n        console.error('Error creating customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to create customer' },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function PUT(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const customer_id = url.searchParams.get('customer_id');\n        const body = await request.json();\n\n        const customerIdValidation = customerIdSchema.safeParse({ customer_id });\n        if (!customerIdValidation.success) {\n            return NextResponse.json(\n                { error: customerIdValidation.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const updateValidation = updateCustomerSchema.safeParse(body);\n        if (!updateValidation.success) {\n            return NextResponse.json(\n                { error: updateValidation.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { customer_id: validCustomerId } = customerIdValidation.data;\n        const customer = await dodopaymentsClient.customers.update(validCustomerId, updateValidation.data);\n        return NextResponse.json(customer);\n    } catch (error) {\n        console.error('Error updating customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to update customer' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(dodopayments)/customer/subscriptions/route.ts",
      "type": "template",
      "content": "import { dodopaymentsClient } from \"@/lib/dodopayments\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst subscriptionQuerySchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const customer_id = url.searchParams.get('customer_id');\n\n        const validationResult = subscriptionQuerySchema.safeParse({ customer_id });\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const subscriptions = await dodopaymentsClient.subscriptions.list({\n            customer_id: validationResult.data.customer_id,\n        });\n\n        return NextResponse.json(subscriptions);\n    } catch (error) {\n        console.error('Error fetching subscriptions:', error);\n        return NextResponse.json({ error: 'Failed to fetch subscriptions' }, { status: 500 });\n    }\n}"
    },
    {
      "target": "app/api/(dodopayments)/product/route.ts",
      "type": "template",
      "content": "import { dodopaymentsClient } from \"@/lib/dodopayments\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst productIdSchema = z.object({\n    product_id: z.string().min(1, \"Product ID is required\"),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const queryParams = {\n            product_id: url.searchParams.get('product_id'),\n        };\n        const validationResult = productIdSchema.safeParse(queryParams);\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { product_id } = validationResult.data;\n\n        const product = await dodopaymentsClient.products.retrieve(product_id);\n        return NextResponse.json(product);\n    } catch (error) {\n        console.error('Error retrieving product:', error);\n        return NextResponse.json(\n            { error: 'Failed to retrieve product' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(dodopayments)/products/route.ts",
      "type": "template",
      "content": "import { dodopaymentsClient } from \"@/lib/dodopayments\";\nimport { NextResponse } from \"next/server\";\n\nexport async function GET() {\n    try {\n        const products = await dodopaymentsClient.products.list();\n        return NextResponse.json(products.items);\n    } catch (error) {\n        console.error('Error fetching products:', error);\n        return NextResponse.json(\n            { error: \"Failed to fetch products\" },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/(dodopayments)/webhook/route.ts",
      "type": "template",
      "content": "import { Webhook } from \"standardwebhooks\";\nimport { headers } from \"next/headers\";\nimport { dodopaymentsClient } from \"@/lib/dodopayments\";\n\nconst webhook = new Webhook(process.env.DODO_PAYMENTS_WEBHOOK_KEY!);\n\nexport async function POST(request: Request) {\n  const headersList =  await headers();\n  try {\n    const rawBody = await request.text();\n    const webhookHeaders = {\n      \"webhook-id\": headersList.get(\"webhook-id\") || \"\",\n      \"webhook-signature\": headersList.get(\"webhook-signature\") || \"\",\n      \"webhook-timestamp\": headersList.get(\"webhook-timestamp\") || \"\",\n    };\n    await webhook.verify(rawBody, webhookHeaders);\n    const payload = JSON.parse(rawBody);\n\n    if (payload.data.payload_type === \"Subscription\") {\n      switch (payload.type) {\n        case \"subscription.active\":\n          const subscription = await dodopaymentsClient.subscriptions.retrieve(payload.data.subscription_id);\n          console.log(\"-------SUBSCRIPTION DATA START ---------\")\n          console.log(subscription)\n          console.log(\"-------SUBSCRIPTION DATA END ---------\")\n          break;\n        case \"subscription.failed\":\n          break;\n        case \"subscription.cancelled\":\n          break;\n        case \"subscription.renewed\":\n          break;\n        case \"subscription.on_hold\":\n          break\n        default:\n          break;\n      }\n    } else if (payload.data.payload_type === \"Payment\") {\n        switch (payload.type) {\n            case \"payment.succeeded\":\n              const paymentDataResp = await dodopaymentsClient.payments.retrieve(payload.data.payment_id)\n              console.log(\"-------PAYMENT DATA START ---------\")\n              console.log(paymentDataResp)\n              console.log(\"-------PAYMENT DATA END ---------\")\n              break;\n            default:\n                break;\n        }\n    }\n    return Response.json(\n      { message: \"Webhook processed successfully\" },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.log(\" ----- webhoook verification failed -----\")\n    console.log(error)\n    return Response.json(\n      { message: \"Webhook processed successfully\" },\n      { status: 200 }\n    );\n  }\n}"
    }
  ],
  "dependencies": [
    "dodopayments",
    "standardwebhooks"
  ]
}